//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.11.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from ..\..\antlr4-grammar\SinumerikNC.g4 by ANTLR 4.11.1

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.11.1")]
[System.CLSCompliant(false)]
public partial class SinumerikNCParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		ID=1, WHITESPACE=2, NAME=3, NEWLINE=4, COMMENT=5, HIDE=6, BLOCK_NUMBER=7, 
		INT_POSITIVE=8, INT=9, REAL_POSITIVE=10, REAL=11, BIN=12, HEX=13, BOOL=14, 
		PI=15, DEFINE=16, TOOL_OFFSET_LENGTH_RADIUS=17, TOOL_OFFSET_LENGTH=18, 
		TOOL_OFFSET_RADIUS=19, SET_MASTER_SPINDLE=20, GRINDING_WHEEL_PERIPHERAL_SPEED_ON=21, 
		GRINDING_WHEEL_PERIPHERAL_SPEED_OFF=22, FEED_GROUP=23, FEED_GROUP_EFFECTIVE_RADIUS=24, 
		WAIT_FOR_POSITION=25, WAIT_FOR_MARKER=26, WAIT_FOR_SPINDLE=27, SPINDLE_POSITION_CONTROL_MODE_ON=28, 
		SPINDLE_POSITION_CONTROL_MODE_OFF=29, SPINDLE_POSITIONING_IMMEDIATE=30, 
		MOTION_END_FINE=31, MOTION_END_COARSE=32, MOTION_END_INTERPOLATION=33, 
		MOTION_END_INTERPOLATION_BREAK=34, FEEDRATE_PATH_ROTARY_AXIS_ON=35, FEEDRATE_PATH_ROTARY_AXIS_OFF=36, 
		FEEDRATE_OVERRIDE_RAPID_TRAVERSE_VELOCITY=37, PROCEDURE_END=38, TOOL_CORRECTION_SUPPRESSION=39, 
		TOOL_OFFSET=40, MASTER_SPINDLE_SPEED_LIMIT=41, POSITIONING_IN_SECTIONS=42, 
		POSITIONING_IMMEDIATE=43, SPINDLE_POSITIONING_DELAYED=44, FEEDRATE_OVERRIDE_POSITION_OR_SPINDLE=45, 
		PROCEDURE=46, TOOL_CUTTING_SPEED=47, DEF=48, ABSOLUTE_COORDINATE_NEGATIVE=49, 
		ABSOLUTE_COORDINATE_POSITIVE=50, POSITIONING_DELAYED=51, CONSTANT_CUTTING_RATE_REFERENCE_AXIS=52, 
		FEEDRATE_PATH_ROTARY_AXIS=53, SPINDLE_IDENTIFIER=54, FEEDRATE_OVERRIDE_PATH=55, 
		ACCELERATION_COMPENSATION=56, FEEDRATE_OVERRIDE_AXIAL_HANDWHEEL=57, AS=58, 
		FEEDRATE_LIMIT=59, FEEDRATE_POSITION_AXIS=60, ABSOLUTE_COORDINATE=61, 
		INCREMENTAL_COORDINATE=62, DIRECT_APPROACH_COORDINATE=63, FEEDRATE_OVERRIDE_PATH_HANDWHEEL=64, 
		ADDITIONAL_FUNCTION=65, AUXILIARY_FUNCTION=66, PREPARATORY_FUNCTION=67, 
		X_AXIS=68, Y_AXIS=69, Z_AXIS=70, A_AXIS=71, B_AXIS=72, C_AXIS=73, SPINDLE=74, 
		FEEDRATE=75, TOOL=76, TOOL_CORRECTION=77, BOOL_TYPE=78, CHAR_TYPE=79, 
		INT_TYPE=80, REAL_TYPE=81, STRING_TYPE=82, AXIS_TYPE=83, FRAME_TYPE=84, 
		OPEN_PAREN=85, CLOSE_PAREN=86, OPEN_BRACKET=87, CLOSE_BRACKET=88, LESS=89, 
		LESS_EQUAL=90, GREATER=91, GREATER_EQUAL=92, EQUAL=93, NOT_EQUAL=94, LEFT_SHIFT=95, 
		RIGHT_SHIFT=96, ADD=97, INC=98, SUB=99, DEC=100, MUL=101, DIV=102, MOD=103, 
		ASSIGNMENT=104, DOLLAR=105, POINT=106, RESERVED=107, PROGRAM_NAME_SIMPLE=108, 
		PROGRAM_NAME_EXTENDED=109;
	public const int
		RULE_file = 0, RULE_part = 1, RULE_type = 2, RULE_procedure = 3;
	public static readonly string[] ruleNames = {
		"file", "part", "type", "procedure"
	};

	private static readonly string[] _LiteralNames = {
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, "'$PI'", "'define'", "'tofflr'", "'toffl'", "'toffr'", 
		"'setms'", "'gwpson'", "'gwpsof'", "'fgroup'", "'fgref'", "'waitp'", "'waitmc'", 
		"'waits'", "'spcon'", "'spcof'", "'sposa'", "'finea'", "'coarsea'", "'ipoenda'", 
		"'ipobrka'", "'fpraon'", "'fpraof'", "'ovrrap'", "'endproc'", "'supd'", 
		"'toff'", "'lims'", "'posp'", "'posa'", "'spos'", "'ovra'", "'proc'", 
		"'svc'", "'def'", "'acn'", "'acp'", "'pos'", "'scc'", "'fpr'", "'spi'", 
		"'ovr'", "'acc'", "'fda'", "'as'", "'fl'", "'fa'", "'ac'", "'ic'", "'dc'", 
		"'fd'", null, null, null, "'x'", "'y'", "'z'", "'a'", "'b'", "'c'", "'s'", 
		"'f'", "'t'", "'d'", "'bool'", "'char'", "'int'", "'real'", "'string'", 
		"'axis'", "'frame'", "'('", "')'", "'['", "']'", "'<'", "'<='", "'>'", 
		"'>='", "'=='", "'<>'", "'<<'", "'>>'", "'+'", "'++'", "'-'", "'--'", 
		"'*'", "'/'", "'%'", "'='", "'$'", "'.'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "ID", "WHITESPACE", "NAME", "NEWLINE", "COMMENT", "HIDE", "BLOCK_NUMBER", 
		"INT_POSITIVE", "INT", "REAL_POSITIVE", "REAL", "BIN", "HEX", "BOOL", 
		"PI", "DEFINE", "TOOL_OFFSET_LENGTH_RADIUS", "TOOL_OFFSET_LENGTH", "TOOL_OFFSET_RADIUS", 
		"SET_MASTER_SPINDLE", "GRINDING_WHEEL_PERIPHERAL_SPEED_ON", "GRINDING_WHEEL_PERIPHERAL_SPEED_OFF", 
		"FEED_GROUP", "FEED_GROUP_EFFECTIVE_RADIUS", "WAIT_FOR_POSITION", "WAIT_FOR_MARKER", 
		"WAIT_FOR_SPINDLE", "SPINDLE_POSITION_CONTROL_MODE_ON", "SPINDLE_POSITION_CONTROL_MODE_OFF", 
		"SPINDLE_POSITIONING_IMMEDIATE", "MOTION_END_FINE", "MOTION_END_COARSE", 
		"MOTION_END_INTERPOLATION", "MOTION_END_INTERPOLATION_BREAK", "FEEDRATE_PATH_ROTARY_AXIS_ON", 
		"FEEDRATE_PATH_ROTARY_AXIS_OFF", "FEEDRATE_OVERRIDE_RAPID_TRAVERSE_VELOCITY", 
		"PROCEDURE_END", "TOOL_CORRECTION_SUPPRESSION", "TOOL_OFFSET", "MASTER_SPINDLE_SPEED_LIMIT", 
		"POSITIONING_IN_SECTIONS", "POSITIONING_IMMEDIATE", "SPINDLE_POSITIONING_DELAYED", 
		"FEEDRATE_OVERRIDE_POSITION_OR_SPINDLE", "PROCEDURE", "TOOL_CUTTING_SPEED", 
		"DEF", "ABSOLUTE_COORDINATE_NEGATIVE", "ABSOLUTE_COORDINATE_POSITIVE", 
		"POSITIONING_DELAYED", "CONSTANT_CUTTING_RATE_REFERENCE_AXIS", "FEEDRATE_PATH_ROTARY_AXIS", 
		"SPINDLE_IDENTIFIER", "FEEDRATE_OVERRIDE_PATH", "ACCELERATION_COMPENSATION", 
		"FEEDRATE_OVERRIDE_AXIAL_HANDWHEEL", "AS", "FEEDRATE_LIMIT", "FEEDRATE_POSITION_AXIS", 
		"ABSOLUTE_COORDINATE", "INCREMENTAL_COORDINATE", "DIRECT_APPROACH_COORDINATE", 
		"FEEDRATE_OVERRIDE_PATH_HANDWHEEL", "ADDITIONAL_FUNCTION", "AUXILIARY_FUNCTION", 
		"PREPARATORY_FUNCTION", "X_AXIS", "Y_AXIS", "Z_AXIS", "A_AXIS", "B_AXIS", 
		"C_AXIS", "SPINDLE", "FEEDRATE", "TOOL", "TOOL_CORRECTION", "BOOL_TYPE", 
		"CHAR_TYPE", "INT_TYPE", "REAL_TYPE", "STRING_TYPE", "AXIS_TYPE", "FRAME_TYPE", 
		"OPEN_PAREN", "CLOSE_PAREN", "OPEN_BRACKET", "CLOSE_BRACKET", "LESS", 
		"LESS_EQUAL", "GREATER", "GREATER_EQUAL", "EQUAL", "NOT_EQUAL", "LEFT_SHIFT", 
		"RIGHT_SHIFT", "ADD", "INC", "SUB", "DEC", "MUL", "DIV", "MOD", "ASSIGNMENT", 
		"DOLLAR", "POINT", "RESERVED", "PROGRAM_NAME_SIMPLE", "PROGRAM_NAME_EXTENDED"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "SinumerikNC.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static SinumerikNCParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public SinumerikNCParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public SinumerikNCParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class FileContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(SinumerikNCParser.Eof, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PartContext[] part() {
			return GetRuleContexts<PartContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PartContext part(int i) {
			return GetRuleContext<PartContext>(i);
		}
		public FileContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_file; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISinumerikNCListener typedListener = listener as ISinumerikNCListener;
			if (typedListener != null) typedListener.EnterFile(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISinumerikNCListener typedListener = listener as ISinumerikNCListener;
			if (typedListener != null) typedListener.ExitFile(this);
		}
	}

	[RuleVersion(0)]
	public FileContext file() {
		FileContext _localctx = new FileContext(Context, State);
		EnterRule(_localctx, 0, RULE_file);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 11;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (((_la) & ~0x3f) == 0 && ((1L << _la) & 6917599396393650848L) != 0 || (((_la - 67)) & ~0x3f) == 0 && ((1L << (_la - 67)) & 6871947671809L) != 0) {
				{
				{
				State = 8;
				part();
				}
				}
				State = 13;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 14;
			Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PartContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ProcedureContext procedure() {
			return GetRuleContext<ProcedureContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INT() { return GetToken(SinumerikNCParser.INT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REAL() { return GetToken(SinumerikNCParser.REAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BLOCK_NUMBER() { return GetToken(SinumerikNCParser.BLOCK_NUMBER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROGRAM_NAME_SIMPLE() { return GetToken(SinumerikNCParser.PROGRAM_NAME_SIMPLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROGRAM_NAME_EXTENDED() { return GetToken(SinumerikNCParser.PROGRAM_NAME_EXTENDED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPEN_PAREN() { return GetToken(SinumerikNCParser.OPEN_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLOSE_PAREN() { return GetToken(SinumerikNCParser.CLOSE_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPEN_BRACKET() { return GetToken(SinumerikNCParser.OPEN_BRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLOSE_BRACKET() { return GetToken(SinumerikNCParser.CLOSE_BRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LESS() { return GetToken(SinumerikNCParser.LESS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LESS_EQUAL() { return GetToken(SinumerikNCParser.LESS_EQUAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GREATER() { return GetToken(SinumerikNCParser.GREATER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GREATER_EQUAL() { return GetToken(SinumerikNCParser.GREATER_EQUAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQUAL() { return GetToken(SinumerikNCParser.EQUAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT_EQUAL() { return GetToken(SinumerikNCParser.NOT_EQUAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LEFT_SHIFT() { return GetToken(SinumerikNCParser.LEFT_SHIFT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RIGHT_SHIFT() { return GetToken(SinumerikNCParser.RIGHT_SHIFT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ADD() { return GetToken(SinumerikNCParser.ADD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INC() { return GetToken(SinumerikNCParser.INC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUB() { return GetToken(SinumerikNCParser.SUB, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEC() { return GetToken(SinumerikNCParser.DEC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MUL() { return GetToken(SinumerikNCParser.MUL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIV() { return GetToken(SinumerikNCParser.DIV, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MOD() { return GetToken(SinumerikNCParser.MOD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGNMENT() { return GetToken(SinumerikNCParser.ASSIGNMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PREPARATORY_FUNCTION() { return GetToken(SinumerikNCParser.PREPARATORY_FUNCTION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMENT() { return GetToken(SinumerikNCParser.COMMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FEED_GROUP() { return GetToken(SinumerikNCParser.FEED_GROUP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ABSOLUTE_COORDINATE() { return GetToken(SinumerikNCParser.ABSOLUTE_COORDINATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INCREMENTAL_COORDINATE() { return GetToken(SinumerikNCParser.INCREMENTAL_COORDINATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FEEDRATE() { return GetToken(SinumerikNCParser.FEEDRATE, 0); }
		public PartContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_part; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISinumerikNCListener typedListener = listener as ISinumerikNCListener;
			if (typedListener != null) typedListener.EnterPart(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISinumerikNCListener typedListener = listener as ISinumerikNCListener;
			if (typedListener != null) typedListener.ExitPart(this);
		}
	}

	[RuleVersion(0)]
	public PartContext part() {
		PartContext _localctx = new PartContext(Context, State);
		EnterRule(_localctx, 2, RULE_part);
		try {
			State = 49;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BOOL_TYPE:
			case CHAR_TYPE:
			case INT_TYPE:
			case REAL_TYPE:
			case STRING_TYPE:
			case AXIS_TYPE:
			case FRAME_TYPE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 16;
				type();
				}
				break;
			case PROCEDURE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 17;
				procedure();
				}
				break;
			case INT:
				EnterOuterAlt(_localctx, 3);
				{
				State = 18;
				Match(INT);
				}
				break;
			case REAL:
				EnterOuterAlt(_localctx, 4);
				{
				State = 19;
				Match(REAL);
				}
				break;
			case BLOCK_NUMBER:
				EnterOuterAlt(_localctx, 5);
				{
				State = 20;
				Match(BLOCK_NUMBER);
				}
				break;
			case PROGRAM_NAME_SIMPLE:
				EnterOuterAlt(_localctx, 6);
				{
				State = 21;
				Match(PROGRAM_NAME_SIMPLE);
				}
				break;
			case PROGRAM_NAME_EXTENDED:
				EnterOuterAlt(_localctx, 7);
				{
				State = 22;
				Match(PROGRAM_NAME_EXTENDED);
				}
				break;
			case OPEN_PAREN:
				EnterOuterAlt(_localctx, 8);
				{
				State = 23;
				Match(OPEN_PAREN);
				}
				break;
			case CLOSE_PAREN:
				EnterOuterAlt(_localctx, 9);
				{
				State = 24;
				Match(CLOSE_PAREN);
				}
				break;
			case OPEN_BRACKET:
				EnterOuterAlt(_localctx, 10);
				{
				State = 25;
				Match(OPEN_BRACKET);
				}
				break;
			case CLOSE_BRACKET:
				EnterOuterAlt(_localctx, 11);
				{
				State = 26;
				Match(CLOSE_BRACKET);
				}
				break;
			case LESS:
				EnterOuterAlt(_localctx, 12);
				{
				State = 27;
				Match(LESS);
				}
				break;
			case LESS_EQUAL:
				EnterOuterAlt(_localctx, 13);
				{
				State = 28;
				Match(LESS_EQUAL);
				}
				break;
			case GREATER:
				EnterOuterAlt(_localctx, 14);
				{
				State = 29;
				Match(GREATER);
				}
				break;
			case GREATER_EQUAL:
				EnterOuterAlt(_localctx, 15);
				{
				State = 30;
				Match(GREATER_EQUAL);
				}
				break;
			case EQUAL:
				EnterOuterAlt(_localctx, 16);
				{
				State = 31;
				Match(EQUAL);
				}
				break;
			case NOT_EQUAL:
				EnterOuterAlt(_localctx, 17);
				{
				State = 32;
				Match(NOT_EQUAL);
				}
				break;
			case LEFT_SHIFT:
				EnterOuterAlt(_localctx, 18);
				{
				State = 33;
				Match(LEFT_SHIFT);
				}
				break;
			case RIGHT_SHIFT:
				EnterOuterAlt(_localctx, 19);
				{
				State = 34;
				Match(RIGHT_SHIFT);
				}
				break;
			case ADD:
				EnterOuterAlt(_localctx, 20);
				{
				State = 35;
				Match(ADD);
				}
				break;
			case INC:
				EnterOuterAlt(_localctx, 21);
				{
				State = 36;
				Match(INC);
				}
				break;
			case SUB:
				EnterOuterAlt(_localctx, 22);
				{
				State = 37;
				Match(SUB);
				}
				break;
			case DEC:
				EnterOuterAlt(_localctx, 23);
				{
				State = 38;
				Match(DEC);
				}
				break;
			case MUL:
				EnterOuterAlt(_localctx, 24);
				{
				State = 39;
				Match(MUL);
				}
				break;
			case DIV:
				EnterOuterAlt(_localctx, 25);
				{
				State = 40;
				Match(DIV);
				}
				break;
			case MOD:
				EnterOuterAlt(_localctx, 26);
				{
				State = 41;
				Match(MOD);
				}
				break;
			case ASSIGNMENT:
				EnterOuterAlt(_localctx, 27);
				{
				State = 42;
				Match(ASSIGNMENT);
				}
				break;
			case PREPARATORY_FUNCTION:
				EnterOuterAlt(_localctx, 28);
				{
				State = 43;
				Match(PREPARATORY_FUNCTION);
				}
				break;
			case COMMENT:
				EnterOuterAlt(_localctx, 29);
				{
				State = 44;
				Match(COMMENT);
				}
				break;
			case FEED_GROUP:
				EnterOuterAlt(_localctx, 30);
				{
				State = 45;
				Match(FEED_GROUP);
				}
				break;
			case ABSOLUTE_COORDINATE:
				EnterOuterAlt(_localctx, 31);
				{
				State = 46;
				Match(ABSOLUTE_COORDINATE);
				}
				break;
			case INCREMENTAL_COORDINATE:
				EnterOuterAlt(_localctx, 32);
				{
				State = 47;
				Match(INCREMENTAL_COORDINATE);
				}
				break;
			case FEEDRATE:
				EnterOuterAlt(_localctx, 33);
				{
				State = 48;
				Match(FEEDRATE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BOOL_TYPE() { return GetToken(SinumerikNCParser.BOOL_TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHAR_TYPE() { return GetToken(SinumerikNCParser.CHAR_TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INT_TYPE() { return GetToken(SinumerikNCParser.INT_TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REAL_TYPE() { return GetToken(SinumerikNCParser.REAL_TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STRING_TYPE() { return GetToken(SinumerikNCParser.STRING_TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AXIS_TYPE() { return GetToken(SinumerikNCParser.AXIS_TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FRAME_TYPE() { return GetToken(SinumerikNCParser.FRAME_TYPE, 0); }
		public TypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISinumerikNCListener typedListener = listener as ISinumerikNCListener;
			if (typedListener != null) typedListener.EnterType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISinumerikNCListener typedListener = listener as ISinumerikNCListener;
			if (typedListener != null) typedListener.ExitType(this);
		}
	}

	[RuleVersion(0)]
	public TypeContext type() {
		TypeContext _localctx = new TypeContext(Context, State);
		EnterRule(_localctx, 4, RULE_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 51;
			_la = TokenStream.LA(1);
			if ( !((((_la - 78)) & ~0x3f) == 0 && ((1L << (_la - 78)) & 127L) != 0) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProcedureContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROCEDURE() { return GetToken(SinumerikNCParser.PROCEDURE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROGRAM_NAME_SIMPLE() { return GetToken(SinumerikNCParser.PROGRAM_NAME_SIMPLE, 0); }
		public ProcedureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedure; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISinumerikNCListener typedListener = listener as ISinumerikNCListener;
			if (typedListener != null) typedListener.EnterProcedure(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISinumerikNCListener typedListener = listener as ISinumerikNCListener;
			if (typedListener != null) typedListener.ExitProcedure(this);
		}
	}

	[RuleVersion(0)]
	public ProcedureContext procedure() {
		ProcedureContext _localctx = new ProcedureContext(Context, State);
		EnterRule(_localctx, 6, RULE_procedure);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 53;
			Match(PROCEDURE);
			State = 54;
			Match(PROGRAM_NAME_SIMPLE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static int[] _serializedATN = {
		4,1,109,57,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,1,0,5,0,10,8,0,10,0,12,0,13,
		9,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,3,1,50,8,1,1,2,1,2,1,3,1,3,1,3,1,3,0,0,4,0,2,4,6,0,1,1,0,78,84,85,
		0,11,1,0,0,0,2,49,1,0,0,0,4,51,1,0,0,0,6,53,1,0,0,0,8,10,3,2,1,0,9,8,1,
		0,0,0,10,13,1,0,0,0,11,9,1,0,0,0,11,12,1,0,0,0,12,14,1,0,0,0,13,11,1,0,
		0,0,14,15,5,0,0,1,15,1,1,0,0,0,16,50,3,4,2,0,17,50,3,6,3,0,18,50,5,9,0,
		0,19,50,5,11,0,0,20,50,5,7,0,0,21,50,5,108,0,0,22,50,5,109,0,0,23,50,5,
		85,0,0,24,50,5,86,0,0,25,50,5,87,0,0,26,50,5,88,0,0,27,50,5,89,0,0,28,
		50,5,90,0,0,29,50,5,91,0,0,30,50,5,92,0,0,31,50,5,93,0,0,32,50,5,94,0,
		0,33,50,5,95,0,0,34,50,5,96,0,0,35,50,5,97,0,0,36,50,5,98,0,0,37,50,5,
		99,0,0,38,50,5,100,0,0,39,50,5,101,0,0,40,50,5,102,0,0,41,50,5,103,0,0,
		42,50,5,104,0,0,43,50,5,67,0,0,44,50,5,5,0,0,45,50,5,23,0,0,46,50,5,61,
		0,0,47,50,5,62,0,0,48,50,5,75,0,0,49,16,1,0,0,0,49,17,1,0,0,0,49,18,1,
		0,0,0,49,19,1,0,0,0,49,20,1,0,0,0,49,21,1,0,0,0,49,22,1,0,0,0,49,23,1,
		0,0,0,49,24,1,0,0,0,49,25,1,0,0,0,49,26,1,0,0,0,49,27,1,0,0,0,49,28,1,
		0,0,0,49,29,1,0,0,0,49,30,1,0,0,0,49,31,1,0,0,0,49,32,1,0,0,0,49,33,1,
		0,0,0,49,34,1,0,0,0,49,35,1,0,0,0,49,36,1,0,0,0,49,37,1,0,0,0,49,38,1,
		0,0,0,49,39,1,0,0,0,49,40,1,0,0,0,49,41,1,0,0,0,49,42,1,0,0,0,49,43,1,
		0,0,0,49,44,1,0,0,0,49,45,1,0,0,0,49,46,1,0,0,0,49,47,1,0,0,0,49,48,1,
		0,0,0,50,3,1,0,0,0,51,52,7,0,0,0,52,5,1,0,0,0,53,54,5,46,0,0,54,55,5,108,
		0,0,55,7,1,0,0,0,2,11,49
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
