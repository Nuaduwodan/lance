using LanceServer.Core.Configuration;
using LanceServer.Core.SymbolTable;
using LanceServer.Parser;
using System.Linq;
using LanceServer.Core.Configuration.DataModel;
using LanceServer.Preprocessor;

namespace LanceServer.Core.Workspace
{
    public class Workspace : IWorkspace
    {
        /// <summary>
        /// Provides the interface to the parser generated by antlr
        /// </summary>
        private IParserManager _parserManager;

        private ICustomPreprocessor _customPreprocessor;
        private readonly IConfigurationManager _configurationManager;

        private IEnumerable<Uri> _workspaceFolders;
        
        private Dictionary<Uri, KnownDocument> _documents = new();
        private Dictionary<string, ISymbol> _globalSymbols = new();

        public Workspace(IParserManager parserManager, ICustomPreprocessor customPreprocessor, IConfigurationManager configurationManager)
        {
            _parserManager = parserManager;
            _customPreprocessor = customPreprocessor;
            _configurationManager = configurationManager;
        }

        /// <summary>
        /// Returns the document with a parse tree and symbol table from memory or creates it.
        /// </summary>
        /// <param name="uri"></param>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        public SymbolisedDocument GetSymbolisedDocument(Uri uri)
        {
            var parsedDocument = GetParsedDocument(uri);
            if (parsedDocument is SymbolisedDocument symbolisedDocument)
            {
                return symbolisedDocument;
            }
            
            var symbolTable = _parserManager.GetSymbolTableForDocument(parsedDocument);
            
            //update symbol table
            DeleteGlobalSymbolsOfFile(uri);

            var globalSymbols = symbolTable.Where(symbol => symbol is ProcedureSymbol).ToList();

            if (parsedDocument.IsGlobalFile)
            {
                globalSymbols.AddRange(symbolTable.Where(symbol => symbol is VariableSymbol or MacroSymbol));
            }

            var localSymbols = symbolTable.Except(globalSymbols);
            
            foreach (var symbol in globalSymbols)
            {
                AddSymbol(symbol);
            }

            var newSymbolisedDocument = new SymbolisedDocument(parsedDocument, localSymbols);
            _documents[uri] = newSymbolisedDocument;
            return newSymbolisedDocument;
        }

        /// <summary>
        /// Returns the document with a parse tree from memory or creates it.
        /// </summary>
        /// <param name="uri">The URI of the document</param>
        public ParsedDocument GetParsedDocument(Uri uri)
        {
            var preprocessedDocument = GetPreprocessedDocument(uri);
            if (preprocessedDocument is ParsedDocument parsedDocument)
            {
                return parsedDocument;
            }

            var newParsedDocument = new ParsedDocument(preprocessedDocument, _parserManager.Parse(preprocessedDocument));
            _documents[uri] = newParsedDocument;
            return newParsedDocument;
        }

        public PreprocessedDocument GetPreprocessedDocument(Uri uri)
        {
            var readDocument = GetReadDocument(uri);
            if (readDocument is PreprocessedDocument preprocessedDocument)
            {
                return preprocessedDocument;
            }
            
            var newPreprocessedDocument = new PreprocessedDocument(readDocument, _customPreprocessor.Filter(readDocument));
            _documents[uri] = newPreprocessedDocument;
            return newPreprocessedDocument;
        }

        /// <summary>
        /// Returns the document from memory or creates it.
        /// </summary>
        /// <param name="uri">The URI of the document</param>
        public ReadDocument GetReadDocument(Uri uri)
        {
            var knownDocument = GetKnownDocument(uri);

            if (knownDocument is ReadDocument readDocument)
            {
                return readDocument;
            }

            var config = _configurationManager.SymbolTableConfiguration;
            var content = FileIoHelper.ReadContent(uri);
            var isGlobalFile = config.GlobalFileExtensions.Contains(knownDocument.FileEnding);
            var isSubProcedure = config.SubProcedureFileExtensions.Contains(knownDocument.FileEnding);
            
            var directories = Path.GetDirectoryName(uri.LocalPath)!.Split(Path.DirectorySeparatorChar);
            var procedureNeedsDeclaration = config.GlobalDirectories.Intersect(directories).Any();
            
            var newReadDocument = new ReadDocument(knownDocument, content, isGlobalFile, isSubProcedure, procedureNeedsDeclaration);
            _documents[uri] = newReadDocument;
            return newReadDocument;
        }

        /// <summary>
        /// Adds the document to this workspace, returns true if successfully added or false if a document with that URI already exists.
        /// </summary>
        /// <param name="uri">The URI of the document</param>
        public KnownDocument GetKnownDocument(Uri uri)
        {
            if (HasDocument(uri))
            {
                return _documents[uri];
            }
            
            var document = new KnownDocument(uri);
            _documents.Add(uri, document);
            return document;
        }

        /// <summary>
        /// Returns true if this workspace has a document with that URI.
        /// </summary>
        /// <param name="uri">The URI of the document</param>
        public bool HasDocument(Uri uri)
        {
            return _documents.ContainsKey(uri);
        }

        /*
        public async Task InitWorkspaceAsync()
        {
            await Task.Run(InitWorkspace);
        }
        */

        public void InitWorkspace()
        {
            var workspaceFolders = _configurationManager.WorkspaceFolders;
            var symbolTableConfig = _configurationManager.SymbolTableConfiguration;
            var fileEndingConfig = _configurationManager.FileEndingConfiguration;
            
            var documentUris = new List<Uri>();
            foreach (var workspaceFolder in workspaceFolders)
            {
                foreach (var fileEnding in fileEndingConfig.FileEndings)
                {
                    documentUris.AddRange(FileIoHelper.GetFilesInDirectory(workspaceFolder, "*"+fileEnding));
                }
            }

            var defFiles = documentUris.Where(uri => symbolTableConfig.GlobalFileExtensions.Contains(Path.GetExtension(uri.LocalPath)));
            documentUris = documentUris.Except(defFiles).ToList();
            
            foreach (var defFile in defFiles)
            {
                GetSymbolisedDocument(defFile);
            }
            /*
            var globalFiles = documentUris.Where(uri => symbolTableConfig.GlobalDirectories.Intersect(Path.GetDirectoryName(uri.LocalPath)!.Split(Path.DirectorySeparatorChar)).Any());
            documentUris = documentUris.Except(globalFiles).ToList();
            
            foreach (var globalFile in globalFiles)
            {
                GetDocumentWithUpdatedSymbolTable(globalFile);
            }
            
            foreach (var documentUri in documentUris)
            {
                GetDocumentWithUpdatedSymbolTable(documentUri);
            }
            */
        }

        /// <summary>
        /// Returns the symbol.
        /// </summary>
        /// <param name="symbolName">The name of the symbol</param>
        /// <param name="documentOfReference">The URI of the document where the symbol is used</param>
        public ISymbol GetSymbol(string symbolName, Uri documentOfReference)
        {
            if (GetSymbolisedDocument(documentOfReference).TryGetSymbol(symbolName, out var symbol))
            {
                return symbol;
            }
            
            if (_globalSymbols.TryGetValue(symbolName.ToLower(), out symbol))
            {
                return symbol;
            }

            return new ErrorSymbol($"Cannot resolve symbol '{symbolName}'");
        }

        public void UpdateDocumentContent(Uri uri, string newContent)
        {
            var document = GetReadDocument(uri);
            if (document.RawContent != newContent)
            {
                _documents[uri] = new ReadDocument(uri, newContent, document.IsGlobalFile, document.IsSubProcedure, document.ProcedureNeedsDeclaration, document.Encoding);
            }

            GetSymbolisedDocument(uri);
        }

        private bool AddSymbol(ISymbol symbol)
        {
            if (_globalSymbols.ContainsKey(symbol.Identifier.ToLower()))
            {
                return false;
            }
            _globalSymbols.Add(symbol.Identifier.ToLower(), symbol);
            return true;
        }

        private void DeleteGlobalSymbolsOfFile(Uri documentUri)
        {
            _globalSymbols = _globalSymbols.Where(pair => pair.Value.SourceDocument != documentUri).ToDictionary(pair => pair.Key, pair => pair.Value);
        }
    }
}